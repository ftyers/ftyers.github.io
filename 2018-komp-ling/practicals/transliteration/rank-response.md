## Отчет по ранжированию

Для начала я создал частотный словарь из тренировочного набора UD_Russian-SynTagRus и сохранил его в freq.txt.

[Подробный код исследования](syntagrus_rank.md)


Я немного изменил алгоритм ранжирования. Минимальный ранг присваивается словам с единичной частотой. Затем ранг увеличивается на единицу, каждый раз когда увеличивается частота слова. Словам с одинаковой частотой соответствует одинаковый ранг.

```
# функция для подсчета рангов 
def count_ranks(freq):
    rank = 1
    min = freq[0][0]
    ranks = []
    for i in range(0, len(freq)):
        if freq[i][0] > min:
            rank = rank + 1
            min = freq[i][0]
        ranks.append((rank, freq[i][0], freq[i][1]))
    return ranks
```

Чтобы алгоритм ранжирования работал корректно, на вход ему нужно падать частотный словарь, отсортированный по возрастанию. Для этого я использовал метод freq.sort(reverse=False).

```
# функция распаковки частотного словаря для алгоритма подсчета рангов
def frequency_list_unpack(filename):
    freq = []
    with open(filename, 'r') as f:
        lines = f.read().splitlines()
        for line in lines:
            (f, w) = line.split('\t')
            freq.append((int(f), w))
    freq.sort(reverse=False)
    return freq
```

Итоговую программу я оформил в файл rank.py. На вход программа принимает название файла с частотным словарем. На выходе выдает ранги в стандартный вывод. Пример использования:

>  $ python3 rank.py freq.txt 

> $ (1, 1, '+7-2=2'), (1, 1, '+7°C'), (1, 1, '+8-6') ... (439, 22727, 'в'), (440, 45571, '.'), (441, 70048, ',')]

[Код программы](rank.py)
