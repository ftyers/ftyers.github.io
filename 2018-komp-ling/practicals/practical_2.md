### Rank algorithm

#### Подготовка данных

Для предобработки данных с SynTagRus я вдумчиво использовала код, предложенный в Practical_2, но в итоге данные стали выглядеть как-то так:

1	Затем1	он1	написал30	,5	что1	летом1	трансляционная1	сеть12	в1	некоторых1	районах1	области1	работала1	недостаточно1	четко2	связи4	с2	тем4	на1	линии2	перегорали2	трансформаторы13	.1	А1	лето1	изобиловало1	грозами1	Своевременно1	исправлять1	повреждения3	не1	удавалось2	по1	трем1	причинам1	:1	во-первых1	заявка1	специалистов1	посланная1	за1	номером1	таким-то1	удовлетворена2	более1	чем1	десять1	процентов6	и1	линейные2	кадры1	до1	сих1	пор1	укомплектованы2	;1	во-вторых1	работу1	тормозили1	неблагоприятные1	метеорологические1	условия1	в-третьих2	…1	Да1	я2	вас1	слушаю10	-1	повторил3	Семен3	Еремеевич1	

Я очень долго возилась с этим неудовлетворительным результатом и пыталась придумать, как же привести его в чувства, пыталась править код на питоне, менять параметры записи, но ничего не получалось.

Тогда я запустила в терминале мой код, который распечатывал нужны мне формат вывода. Я назвала файл before_rank.py

```python
import sys 

vocab = {}
f = open(sys.argv[1], 'r')
for line in f.readlines():
    if '\t' not in line:
        continue
    row = line.split('\t')
    if len(row) != 10:
        continue
    form = row[1]
    if form not in vocab:
        vocab[form] = 0
    vocab[form] = vocab[form] + 1

freq = []
for w in vocab:
    freq.append('%d\t%s' % (vocab[w], w))

freq.sort(reverse=True)
print(*freq, sep='\n')
```

Далее я ввела две команды:

*python3 before_rank.py syntagrus > freq*

*sort freq -nr > freq_sorted*

И получила файл в нужном формате. 

#### rank.py

В итоге мой код выглядит так:

```python
import sys 

freq = []
r = ''
fm = open(sys.argv[1], 'r')
for line in fm.readlines():
    line = line.strip('\n')
    (f, w) = line.split('\t')
    freq.append((int(f), w))


rank = 1
min = freq[0][0]
ranks = []
for i in range(0, len(freq)):
    if freq[i][0] < min:
        rank = rank + 1
        min = freq[i][0]
    ranks.append((rank, freq[i][0], freq[i][1]))


print(ranks)
```

На выходе мы получаем список, в котором самое частотное слово имеет ранг 1, а слова, встречающиеся 1 раз - наименьший ранг (их больше всего). Тут уместно вспомнить **закон Ципфа**, который отлично описывает это явление.
Чтобы записать данные в файл, я использовала команду *rank.py freq_sorted > ranks*


****

### Transliteration 

**1.** В моем коде я сделала несколько проверок контекста для 'е' и 'ё':

(стоит заметить, что буквы 'е' и 'ё' не содержатся в файле, который я подаю на вход транслитератору)

```python
n = 0
final = ''
for w in text:
    if w == 'е':
        if n == 0:  # проверка на первую букву текста
            final += 'je'
        elif text[n-1] not in vowels:
            final += 'е'
        else:
            final += 'je'
    if w == 'ё':
        if n == 0:
            final += 'jo'
        elif text[n-1] is 'ж' or 'ш' or 'ч' or 'щ':
            final += 'o'
        else:
            final += 'jo'
```

**2.**  C 'sh' --> ''с'' можно поступить подобным образом! 

```python
n = 0
final = ''
for w in text:
    if w == 's':
        if n + 1 == 'h'  
            final += 'с'
```
**3.** Можно поставить проверку на следующий/предыдущий символ. Если этот символ - пробел, необходимо будет применить особые правила транслитерации для этого символа. (если такие правила есть)





